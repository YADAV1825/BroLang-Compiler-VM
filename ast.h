// ===================================================================================
// Made by: Rohit Yadav
// NIT Jalandhar
//
// File: ast.h
// Purpose: Defines the Abstract Syntax Tree (AST) structures for the Brolang language.
// Why it's needed:
//   - AST is the intermediate structured representation of source code.
//   - It is generated by the parser after tokenizing input.
//   - This tree structure is then used by later stages (code generation, evaluation).
// ===================================================================================

#pragma once
#include <memory>
#include <vector>
#include <string>

// --------------------------------------------------------------
// Enum: BinaryOp
// Purpose: Represents binary operators in Brolang.
// Why we use it:
//   - Helps the parser and code generator identify which operation to perform.
//   - Covers arithmetic and comparison operators.
// --------------------------------------------------------------
enum class BinaryOp {
    Add,
    Sub,
    Mul,
    Div,
    Equal,    // Used for comparisons like a == b
    Greater,  // Used in conditionals like a > b
    Less      // Used in conditionals like a < b
};

// Forward declarations
struct Expr;
struct Statement;

// Aliases for smart pointers to simplify ownership and memory safety
using ExprPtr = std::shared_ptr<Expr>;
using StmtPtr = std::shared_ptr<Statement>;

// --------------------------------------------------------------
// Base Struct: Expr
// Purpose: Abstract base class for all expressions in the language.
// Implementation:
//   - All specific expressions (numbers, variables, binary ops) inherit from this.
//   - Enables polymorphism and type-safe expression trees.
// --------------------------------------------------------------
struct Expr {
    virtual ~Expr() = default;
};

// --------------------------------------------------------------
// Struct: NumberExpr
// Purpose: Represents a literal number like `10` or `42`.
// --------------------------------------------------------------
struct NumberExpr : public Expr {
    int value;
    NumberExpr(int val) : value(val) {}
};

// --------------------------------------------------------------
// Struct: VariableExpr
// Purpose: Represents a variable reference like `a` or `counter`.
// --------------------------------------------------------------
struct VariableExpr : public Expr {
    std::string name;
    VariableExpr(const std::string& name) : name(name) {}
};

// --------------------------------------------------------------
// Struct: BinaryExpr
// Purpose: Represents expressions like `a + b`, `a * b`, etc.
// Members:
//   - op: the operation (e.g., Add, Sub, Greater)
//   - left: the left operand
//   - right: the right operand
// --------------------------------------------------------------
struct BinaryExpr : public Expr {
    BinaryOp op;
    ExprPtr left;
    ExprPtr right;
    BinaryExpr(BinaryOp op, ExprPtr left, ExprPtr right)
        : op(op), left(left), right(right) {}
};

// --------------------------------------------------------------
// Base Struct: Statement
// Purpose: Abstract base for all types of statements.
// --------------------------------------------------------------
struct Statement {
    virtual ~Statement() = default;
};

// --------------------------------------------------------------
// Struct: LetStatement
// Purpose: Represents variable declarations like `letbro a = 5;`
// Members:
//   - name: the variable being declared
//   - value: the expression assigned to it
// --------------------------------------------------------------
struct LetStatement : public Statement {
    std::string name;
    ExprPtr value;
    LetStatement(const std::string& name, ExprPtr value)
        : name(name), value(value) {}
};

// --------------------------------------------------------------
// Struct: PrintStatement
// Purpose: Represents `printbro(expr);` statements for output.
// --------------------------------------------------------------
struct PrintStatement : public Statement {
    ExprPtr expr;
    PrintStatement(ExprPtr expr) : expr(expr) {}
};

// --------------------------------------------------------------
// Struct: IfStatement
// Purpose: Represents conditional blocks:
//     ifbro (cond) { ... } elsebro { ... }
// Members:
//   - condition: the expression being checked
//   - thenBranch: list of statements if condition is true
//   - elseBranch: list of statements if condition is false
// --------------------------------------------------------------
struct IfStatement : public Statement {
    ExprPtr condition;
    std::vector<StmtPtr> thenBranch;
    std::vector<StmtPtr> elseBranch; 

    IfStatement(ExprPtr condition, std::vector<StmtPtr> thenBranch, std::vector<StmtPtr> elseBranch = {})
        : condition(std::move(condition)),
          thenBranch(std::move(thenBranch)),
          elseBranch(std::move(elseBranch)) {}
};

// --------------------------------------------------------------
// Struct: WhileStatement
// Purpose: Represents loops like `whilebro (cond) { ... }`
// Members:
//   - condition: the loop condition
//   - body: the list of statements to run repeatedly
// --------------------------------------------------------------
struct WhileStatement : public Statement {
    ExprPtr condition;
    std::vector<StmtPtr> body;
    WhileStatement(ExprPtr condition, std::vector<StmtPtr> body)
        : condition(condition), body(body) {}
};

// --------------------------------------------------------------
// Struct: Program
// Purpose: Represents the top-level root node of the AST.
// Holds all statements in order as they appear in the `.bro` file.
// --------------------------------------------------------------
struct Program {
    std::vector<StmtPtr> statements;
};
